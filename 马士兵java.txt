第一章

第二章
01_标识符_关键字_数据类型_1.avi
16:49  程序执行过程，运行时的内存分成不同的区域(栈内存，堆内存，数据区，代码区)
34:00  java基础数据类型包含4类8种
37:25  char类型详解
02_标识符_关键字_数据类型_2.avi
3:22   整形常量的三种表示方式(十进制，八进制(0开头)，十六进制(0x开头))  声明long类型要加L或l(推荐加大写的，小写的像1)
7:30   浮点类型默认为double类型  要声明float类型，要在数字后面加f或F
8:20   long类型数放int里会出错，int类型数放long里不出错
10:21  float类型在小数点后7位开始产生误差，double类型在小数点后15位开始产生误差
03_数据类型转换_1.avi
0:35   boolean类型不能和其他类型转换
2:25   byte,short,char之间不会互相转换，只要运算都转成int
5:50   int类型数直接放入char、byte、short里是可以的，只要不超出表示范围
6:25   byte b1 = 1;byte b2 = 2;byte b3 = (byte)(b1+b2);这里b1+b2算出来的不是byte类型，而是int类型，所以要加强制转换
7:36   float f2 = (float)1e200;当打印f2时会产生溢出，
8:33   byte b3 = (byte)200;这里和float不同，当打印b3不会溢出，只是结果不对，因为int转byte直接砍掉多余的字节，double转float砍掉多余字节后由于浮点数的存储格式问题，会导致溢出
06_运算符.avi
11:36  System.out.println打印时，打印任何东西只要不是字符串，自动转成字符串再打印
07_if分支与for循环.avi
12:42  看别人程序的方法
12_switch语句.avi
0:52   switch语句括号里只能探测int类型

第三章
01_面向对象设计思想_重要_1.avi
23:40  类之间的关系:聚合关系
25:55  类之间的关系:实现关系
28:10  面向对象和面向过程的思想，分别应该怎么去考虑问题
03_JAVA中的面向对象与内存解析_1.avi
3:35   局部变量要先申明再赋值才能使用，成员变量申明后可直接使用，Java会对其赋默认值
04_JAVA中的面向对象与内存解析_2.avi
2:00   构造方法必须名字和类一样且没有返回值
12_方法重载与内存解析.avi
1:44   重载叫overload
17_this关键字.avi
3:21   变量区分不开来的时候(比如成员变量与参数变量同名)，区分的原则是找最近的声明
21_package和import语句_2.avi
3:41   通过classpath找类文件时，package最上层包的父目录必须位于classpath下
9:19   如果要执行的java类有包，执行时要写全类名(包名.类名)
22_package和import语句_3.avi
5:18   怎么打成jar包
25_继承和权限控制_2.avi
5:35   private、default、protected、public访问控制符的访问权限
15:10  private修饰的只在类内部可以访问，子类都无法访问
16:10  对于class的权限修饰只能用public或default
26_重写.avi
2:46   重写叫overwrite或override
27_super关键字.avi
1:13   子类可以拥有和父类相同的属性，可以理解为是和父类的属性不同的2个变量，使用属性名访问子类中的属性，使用super.属性名访问父类中的属性
28_继承中的构造方法_1.avi
1:52   子类可以在自己的构造方法中使用super(参数列表)调用基类的构造方法
2:26   子类也可以在自己的构造方法中使用this(参数列表)调用本类的另外的构造方法
2:39   如果调用super，必须写在子类构造方法的第一行
3:56   如果子类的构造方法中没有显式的调用父类的构造方法，则默认调用父类无参数的构造方法
4:15   如果子类构造方法中没有显式的调用父类构造方法，而父类又没有无参数的构造方法，则编译出错
36_Object类之equals方法.avi
0:15   classpath中当前路径(.)没写最前面，当找类的时候有可能会找到其他目录下的相同类，导致出现莫名其妙的问题
10:26  引用类型用==比较的话，比较的是栈内存中的引用变量的内容
16:00  默认的Object类实现的equals方法和用==比较的效果是一样的
38_对象转型_2.avi
2:12   什么是可扩展性好
41_抽象类.avi
6:42   子类如果不想实现父类的抽象方法，只要把自己定义成抽象类就行了，不用重新定义一遍抽象方法
43_interface_1.avi
1:30   一个抽象类的所有的方法都是抽象的，所有的成员变量都是public static final的话，该抽象类可以被定义为接口
6:00   接口中定义成员变量时，可以不写public static final，写和不写效果是一样的
6:26   一个接口中的方法只能是抽象方法，abstract写不写都是抽象方法，而且方法只能是public的

第四章
03_异常的分类.avi
4:16   Throwable类已知的直接子类Error和Exception，其中Error类是系统内部错误，管不了
6:29   任何继承RuntimeException的异常可以不用捕获，其余的异常必须要捕获
07_异常的其他问题.avi
2:30   try语句块中，基类异常的捕获语句不可以写在子类异常的捕获语句之前
9:21   用throw抛出异常后，之后的语句不会被执行，方法到此结束
9:51   重写方法需要抛出与原方法抛出异常类型一致的异常或不抛出异常

第五章
01_一维数组内存分析.avi
3:58   Java语言中申明数组时不能指定其长度
5:18   数组在刚new出来时，Java会对其自动初始化
02_数组元素的创建和使用.avi
2:15   数组的静态初始化(创建时直接赋值)
04_练习_2.avi
2:52   怎么把字符串内容转成其他数据类型
13_练习_11.avi
0:00   用数组模拟链表
14_练习_12.avi
0:00   二分法查找算法
16_二维数组.avi
9:13   使用System.arraycopy拷贝二维数组的内存情况

第六章
07_StringBuffer.avi
1:00   什么叫可变字符串和不可变字符串
10_Math_and_File.avi
8:20   java.io包中的File类的静态属性separator是路径中分隔文件夹的分隔符(pathSeparator是多个路径之间的分隔符)
17:20  当类在包中时，在类中获取到的当前路径是包这个文件夹所在的目录

第七章
01_容器API_Collection_1.avi
5:00   JDK提供的容器的结构图
17:32  往集合类中添加数据时，只能添加对象，不能添加基础数据类型
02_Collection_2.avi
4:57   两个对象如果equals的话，这2个对象的hashCode应该相等
5:22   当对象用在map接口中作为键使用时，比较对象相等使用的是hashCode方法
8:26   重写equals方法必须重写hashCode方法，当对象作为索引(键)的时候有用
05_Iterator.avi
23:32  Java的各种衍生技术(容器、框架、类库等)，看看哪些想学的、需要学的
25:00  Iterator对象的remove方法是在迭代过程中删除元素的唯一的安全方法

第八章
01_IO初步.avi
8:51   JDK提供的4种抽象IO类(InputStream、OutputStream、Reader、Writer)
03_FileReader_FileWriter.avi
1:16   输出Unicode字符表到文本文件
09_ObjectIO.avi
11:34  transient关键字解释
10_总结.avi
0:21   externalizable接口解释，自己控制自己的序列化过程

第九章
01_线程的基本概念.avi
11:11  Java中怎样起一个新线程(方法一：实现Runnable接口。方法二：继承自Thread类并重写其run方法)
02_Sleep方法.avi
1:33   要新起线程，能实现Runnable接口的尽量不要继承Thread类，因为不能再继承其他类了
15:05  一个线程控制另一个线程的方法
06_线程同步_2.avi
3:07   synchronized关键字
07_线程同步_3.avi
0:23   死锁的原理
7:22   解决死锁问题的一个解决办法：把锁的粒度加粗(锁大对象，不锁小对象，尽量只锁定一个对象)
